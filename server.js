// server.js
const express = require("express");
const WebSocket = require("ws");
const https = require("https");
const path = require("path");
const fs = require("fs");
const os = require('os');

const app = express();
const helmet = require('helmet');

// Add secure headers
app.use(helmet());

// If running behind a proxy (nginx, cloud), trust proxy so req.secure/x-forwarded-proto work
app.set('trust proxy', true);

const server = https.createServer({
    key: fs.readFileSync("certs/server.key"),
    cert: fs.readFileSync("certs/server.cert"),
}, app);

const wss = new WebSocket.Server({ server });

// Increase payload limit for large images - MUST BE BEFORE ROUTES!
app.use(express.json({ limit: '10mb' }));

let connectedClients = [];

// WebSocket for real-time communication to frontend
wss.on("connection", ws => {
    // New websocket connection
    connectedClients.push(ws);

    ws.on("close", () => {
        // Client disconnected
        connectedClients = connectedClients.filter(client => client !== ws);
    });

    ws.on("error", err => {
        console.error("WebSocket error:", err);
    });
});

// Broadcast function to all connected clients
function broadcastToClients(message) {
    connectedClients.forEach(client => {
        if (client.readyState === WebSocket.OPEN) {
            try {
                client.send(JSON.stringify(message));
            } catch (error) {
                console.error("Error sending to client:", error);
            }
        }
    });
}

app.get("/", (req, res) => {
    res.sendFile(path.join(__dirname, "public", "index.html"));
});

// API endpoint for face detection data from phone
app.post("/api", (req, res) => {
    console.log("Received face detection data from phone");

    const {
        count,
        image,
        timestamp,
        detections,
        imageQuality,
        videoResolution,
        facingMode
    } = req.body;

    if (count !== undefined && image && timestamp) {
        // Ensure the detections directory exists
        const detectionsDir = path.join(__dirname, "detections");
        if (!fs.existsSync(detectionsDir)) {
            fs.mkdirSync(detectionsDir);
        }

        const date = new Date(timestamp);
        const dateStr = `${date.getDate()}-${date.getMonth() + 1}-${date.getFullYear()}`;
        const timeStr = `${String(date.getHours()).padStart(2, '0')}-${String(date.getMinutes()).padStart(2, '0')}-${String(date.getSeconds()).padStart(2, '0')}`;

        const filename = `${count} person on ${dateStr} ${timeStr}.md`;
        const filepath = path.join(detectionsDir, filename);

        let mdContent = `# Face Detection Report
**Date:** ${dateStr} ${timeStr.replace(/-/g, ':')}  
**Faces Detected:** ${count}  
**Camera:** ${facingMode === 'user' ? 'Front' : 'Back'}  
**Video Resolution:** ${videoResolution ? `${videoResolution.width}x${videoResolution.height}` : 'Unknown'}  
**Image Quality:** ${imageQuality || 'Unknown'}  

## Detection Summary
`;

        if (detections && detections.length > 0) {
            detections.forEach((detection) => {
                mdContent += `
### Face ${detection.faceNumber}
- **Position:** (${detection.box.x}, ${detection.box.y})
- **Size:** ${detection.box.width} x ${detection.box.height} pixels
- **Center Point:** (${detection.center.x}, ${detection.center.y})
- **Detection Confidence:** ${(detection.score * 100).toFixed(1)}%
- **Face Area:** ${detection.box.width * detection.box.height} pixels²
`;

                if (detection.age !== undefined) {
                    mdContent += `- **Estimated Age:** ${detection.age} years\n`;
                }

                if (detection.gender) {
                    mdContent += `- **Gender:** ${detection.gender} (${(detection.genderProbability * 100).toFixed(1)}% confidence)\n`;
                }

                if (detection.expressions) {
                    mdContent += `- **Facial Expressions:**\n`;
                    Object.entries(detection.expressions).forEach(([expr, score]) => {
                        mdContent += `  - ${expr.charAt(0).toUpperCase() + expr.slice(1)}: ${(score * 100).toFixed(1)}%\n`;
                    });
                }

                if (detection.landmarks) {
                    mdContent += `- **Facial Landmarks:** ${detection.landmarks.length} points detected\n`;
                }
            });
        }

        mdContent += `
## Technical Details
- **Timestamp:** ${timestamp}
- **Detection Algorithm:** face-api.js TinyFaceDetector
- **Total Detection Time:** ~1000ms interval
- **Image Format:** JPEG with quality ${imageQuality || 'default'}

## Captured Image
*Red rectangles show detected face regions with face numbers*

![Face Detection Result](${image})

---
*Generated by Screensaver Pet Face Detection System*
`;

        try {
            fs.writeFileSync(filepath, mdContent);

            // Broadcast to frontend that a face was detected
            broadcastToClients({
                type: 'faceDetected',
                count: count,
                timestamp: timestamp,
                detections: detections,
                facingMode: facingMode
            });

        } catch (err) {
            console.error("Error saving file:", err);
            const fallbackFilename = `detection_${Date.now()}.md`;
            const fallbackPath = path.join(detectionsDir, fallbackFilename);
            try {
                fs.writeFileSync(fallbackPath, mdContent);
                console.log(`Saved detection to fallback: ${fallbackFilename}`);
            } catch (err2) {
                console.error("Failed to save fallback detection:", err2);
            }
        }
    }

    res.json({ success: true, message: "Face detection data received and processed" });

});

// Admin route to view md files
// -- replace the existing /admin route with this version --
app.get("/admin", (req, res) => {
    const page = parseInt(req.query.page) || 1;
    const filesPerPage = 10;
    const detectionsDir = path.join(__dirname, "detections");

    if (!fs.existsSync(detectionsDir)) {
        fs.mkdirSync(detectionsDir);
    }

    const files = fs.readdirSync(detectionsDir)
        .filter(file => file.endsWith('.md'))
        .map(file => ({
            name: file,
            path: path.join(detectionsDir, file),
            mtime: fs.statSync(path.join(detectionsDir, file)).mtime
        }))
        .sort((a, b) => b.mtime - a.mtime);

    const totalPages = Math.ceil(files.length / filesPerPage);
    const startIndex = (page - 1) * filesPerPage;
    const endIndex = startIndex + filesPerPage;
    const filesForPage = files.slice(startIndex, endIndex);

    // Simple markdown -> HTML converter (keeps things safe-ish)
    function escapeHtml(str) {
        return str
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;');
    }

    function mdToHtml(md) {
        if (!md) return '';

        // 1) Convert code fences ```...``` first (keep raw content)
        md = md.replace(/```([\s\S]*?)```/g, (m, code) => {
            return `<pre><code>${escapeHtml(code)}</code></pre>`;
        });

        // 2) Images: ![alt](url)
        md = md.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (m, alt, url) => {
            return `<img src="${escapeHtml(url)}" alt="${escapeHtml(alt)}" style="max-width:100%;border-radius:8px;margin:8px 0;">`;
        });

        // 3) Links: [text](url)
        md = md.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (m, text, url) => {
            return `<a href="${escapeHtml(url)}" target="_blank" rel="noopener noreferrer">${escapeHtml(text)}</a>`;
        });

        // 4) Headings
        md = md.replace(/^### (.+)$/gm, '<h4>$1</h4>');
        md = md.replace(/^## (.+)$/gm, '<h3>$1</h3>');
        md = md.replace(/^# (.+)$/gm, '<h2>$1</h2>');

        // 5) Horizontal rule: --- to <hr>
        md = md.replace(/^---$/gm, '<hr>');

        // 6) Bold and italic and inline code
        md = md.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
        md = md.replace(/\*(.+?)\*/g, '<em>$1</em>');
        md = md.replace(/`([^`]+)`/g, '<code>$1</code>');

        // 7) Lists: convert consecutive lines starting with - or * into <ul>
        const lines = md.split('\n');
        let out = '';
        let inList = false;

        for (let i = 0; i < lines.length; i++) {
            let line = lines[i];

            // Skip already converted blocks (pre/code, images etc.)
            if (/^<pre>/.test(line) || /^<img/.test(line) || /^<h[2-4]>/.test(line) || /^<ul>/.test(line) || /^<p>/.test(line) || /^<a /.test(line) || /^<code>/.test(line)) {
                out += line + '\n';
                continue;
            }

            if (/^\s*[-*]\s+/.test(line)) {
                if (!inList) {
                    inList = true;
                    out += '<ul>\n';
                }
                out += '<li>' + escapeHtml(line.replace(/^\s*[-*]\s+/, '')) + '</li>\n';
            } else {
                if (inList) {
                    out += '</ul>\n';
                    inList = false;
                }

                if (line.trim() === '') {
                    out += '\n';
                } else {
                    // If line already contains HTML (from replacements above) don't escape
                    if (/^<.*>$/.test(line.trim())) {
                        out += line + '\n';
                    } else {
                        out += '<p>' + escapeHtml(line) + '</p>\n';
                    }
                }
            }
        }
        if (inList) out += '</ul>\n';

        // 8) After list/paragraph building, restore inline replacements we made earlier (headings, strong, em, code, links)
        // Note: we applied some replacements before escaping lines, so some HTML tags will be escaped; to keep it simple,
        // re-run a couple inline replacements on the output (non-greedy).
        out = out
            .replace(/&lt;h2&gt;(.*?)&lt;\/h2&gt;/g, '<h2>$1</h2>')
            .replace(/&lt;h3&gt;(.*?)&lt;\/h3&gt;/g, '<h3>$1</h3>')
            .replace(/&lt;h4&gt;(.*?)&lt;\/h4&gt;/g, '<h4>$1</h4>')
            .replace(/&lt;strong&gt;(.*?)&lt;\/strong&gt;/g, '<strong>$1</strong>')
            .replace(/&lt;em&gt;(.*?)&lt;\/em&gt;/g, '<em>$1</em>')
            .replace(/&lt;code&gt;(.*?)&lt;\/code&gt;/g, '<code>$1</code>');

        // small tidy-up: collapse multiple blank lines
        out = out.replace(/\n{3,}/g, '\n\n');

        return out;
    }

    let html = `
    <!DOCTYPE html>
    <html>
    <head>
        <meta charset="utf-8" />
        <title>Admin - Face Detections</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <style>
            :root {
                --bg: #0b0d10;
                --panel: #0f1720;
                --muted: #99a1ad;
                --accent: #35b0ff;
                --card: #0b1220;
                --glass: rgba(255,255,255,0.03);
            }
            ::selection { background-color: white; color: black; }
            html,body { height:100%; margin:0; font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; background: var(--bg); color: #e6eef6; }
            .container { max-width: 1100px; margin: 28px auto; padding: 20px; }
            header { display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:18px; }
            h1 { margin:0; font-size:22px; letter-spacing: -0.02em; }
            .stats { color: var(--muted); font-size:13px; }
            .file { background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.02)); border-radius: 10px; padding: 18px; margin: 18px 0; box-shadow: 0 6px 18px rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.03); }
            .filename { font-weight: 600; color: #dbe9ff; margin-bottom:8px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; }
            .content { line-height: 1.6; color: #d6e6ff; }
            .content h2, .content h3, .content h4 { margin: 12px 0 8px; color: #ffffff; }
            .content p { margin: 6px 0; color: var(--muted); }
            .content img { max-width: 420px; border-radius: 8px; margin: 8px 0; display:block; }
            pre { background: #020617; padding: 12px; border-radius: 8px; overflow:auto; color:#bfe7ff; font-size:13px; }
            code { background: rgba(255,255,255,0.03); padding: 2px 6px; border-radius: 6px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, "Roboto Mono", monospace; }
            .pagination { display:flex; gap:8px; justify-content:center; margin: 28px 0; flex-wrap:wrap; }
            .pagination a { padding:8px 12px; background: var(--panel); border-radius:8px; text-decoration:none; color:#cfeaff; border:1px solid rgba(255,255,255,0.03); }
            .pagination a.current { background: linear-gradient(90deg,var(--accent), #2ec7a7); color: #081421; font-weight:700; border: none; }
            footer { text-align:center; color:var(--muted); margin-top: 28px; font-size: 13px; }
            .toprow { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
            .toprow .search { padding:8px 12px; background:var(--card); border-radius:8px; border:1px solid rgba(255,255,255,0.02); color: var(--muted); }
            @media (max-width:720px) {
                .container { padding: 12px; }
            }
        </style>
    </head>
    <body>
        <div class="container">
            <header>
                <div>
                    <h1>Face Detection Admin</h1>
                    <div class="stats">Total detections: ${files.length} &nbsp;&middot;&nbsp; Page ${page} of ${totalPages}</div>
                </div>
                <div class="toprow">
                    <div class="search">Showing latest detections (dark mode)</div>
                </div>
            </header>
    `;

    filesForPage.forEach(file => {
        const content = fs.readFileSync(file.path, 'utf8');
        const contentHtml = mdToHtml(content);
        html += `
            <div class="file">
                <div class="filename">${file.name}</div>
                <div class="content">${contentHtml}</div>
            </div>
        `;
    });

    if (totalPages > 1) {
        html += '<div class="pagination">';
        if (page > 1) {
            html += `<a href="/admin?page=${page - 1}">← Previous</a>`;
        }
        for (let i = 1; i <= totalPages; i++) {
            if (i === page) {
                html += `<a href="/admin?page=${i}" class="current">${i}</a>`;
            } else {
                html += `<a href="/admin?page=${i}">${i}</a>`;
            }
        }
        if (page < totalPages) {
            html += `<a href="/admin?page=${page + 1}">Next →</a>`;
        }
        html += '</div>';
    }

    html += `
        <footer>Generated by Blinky Face Detection System — Dark admin view</footer>
        </div>
    </body>
    </html>
    `;

    res.send(html);
});

// Serve static files with caching and without directory index
app.use(express.static(path.join(__dirname, "public"), {
    maxAge: '7d',
    index: false
}));

// Redirect to HTTPS when behind a proxy that sets x-forwarded-proto
app.use((req, res, next) => {
    const proto = req.headers['x-forwarded-proto'];
    if (!req.secure && proto && proto !== 'https') {
        return res.redirect('https://' + req.headers.host + req.url);
    }
    next();
});

// /camera serves phone.html
app.get("/camera", (req, res) => {
    res.sendFile(path.join(__dirname, "public", "phone.html"));
});

// Debug endpoint
app.get("/status", (req, res) => {
    res.json({
        connectedClients: connectedClients.length,
        timestamp: new Date().toISOString()
    });
});

// Server errors
server.on("error", err => {
    console.error("Server error:", err);
});

// Global error handlers
process.on("uncaughtException", err => {
    console.error("Uncaught exception:", err);
});
process.on("unhandledRejection", err => {
    console.error("Unhandled promise rejection:", err);
});

// Local IP function
function getLocalIp() {
    const interfaces = os.networkInterfaces();
    for (const name of Object.keys(interfaces)) {
        for (const iface of interfaces[name]) {
            if (iface.family === 'IPv4' && !iface.internal) {
                return iface.address;
            }
        }
    }
    return 'localhost';
}

const ip = getLocalIp();
const port = process.env.PORT || 8080;

server.listen(port, "0.0.0.0", () => {
    console.log(`Server running on https://${ip}:${port}`);
    console.log(`Open https://${ip}:${port}/camera on the camera device`);
    console.log(`Open https://${ip}:${port}/ to see Screensaver Pet`);
    console.log(`Open https://${ip}:${port}/admin for the admin panel`);
});

// Debug info
// setInterval(() => {
//     console.log(`Connected frontend clients: ${connectedClients.length}`);
// }, 30000);